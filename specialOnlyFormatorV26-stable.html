<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WEBÊñáÂ≠óÊèêÂèñÂô®</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ffffff;
            font-family: Arial, sans-serif;
            margin: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #48c9b0; /* ËñÑËç∑Á∂† */
        }
        textarea, input[type="text"] {
            background-color: #2c2c2c;
            color: #ffffff;
            border: 1px solid #555;
            padding: 10px;
            margin: 5px;
            width: 100%;
            max-width: 600px;
            border-radius: 5px;
        }
        textarea {
            height: 150px;
            resize: vertical;
        }
        .condition-group {
            display: flex;
            align-items: center;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .condition-group input[type="text"] {
            width: 110px;
        }
        button {
            background-color: #6a0dad; /* Á¥´Ëâ≤ */
            color: #ffffff;
            border: none;
            padding: 5px 5px;
            margin: 5px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
        }
        button:hover {
            background-color: #7b1fa2;
        }
        .remove-btn {
            background-color: #d32f2f; /* Á¥ÖËâ≤ÔºåÁî®ÊñºÂà™Èô§ */
        }
        .remove-btn:hover {
            background-color: #e53935;
        }
        #conditions-container {
            width: 100%;
            max-width: 600px;
        }
        .not-inputs {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .not-pair {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        input[type="file"] {
            display: none;
        }
        label {
            background-color: #6a0dad;
            color: #ffffff;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
        }
        label:hover {
            background-color: #7b1fa2;
        }
        .filter-controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
        }
        #postFilters {
            width: 100px;
        }
        
        /* Êñ∞Â¢ûÁöÑonlyTextÊ®£Âºè */
        .checkbox-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            width: 100%;
            max-width: 600px;
        }
        .checkbox-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            border-radius: 5px;
            background-color: #2a2a2a;
        }
        .checkbox-item input {
            margin-right: 5px;
        }
        .checkbox-item label {
            margin-right: 5px;
            font-size: 10px;
        }
        .row-toggle {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            border-radius: 5px;
            background-color: #3a3a3a;
            margin-left: 10px;
        }
        .row-toggle label {
            margin-left: 5px;
            font-size: 10px;
        }
        /* ÊÆµËêΩÈ¢úËâ≤ */
        .color-0 { color: #ff7b7b; }
        .color-1 { color: #7bb4ff; }
        .color-2 { color: #7bff8c; }
        .color-3 { color: #ffdd7b; }
        .color-4 { color: #d67bff; }
        .color-5 { color: #7bfff3; }
        .color-6 { color: #ff7be8; }
        .color-7 { color: #a3ff7b; }
        .para-block {
            margin-bottom: 1em;
        }
        #outputDiv {
            width: 100%;
            min-height: 150px;
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 16px;
            white-space: pre-wrap;
            max-width: 600px;
        }
    </style>
</head>
<body>
    <h1>WEBÊñáÂ≠óÊèêÂèñÂô®</h1>
    <input type="text" id="urlInput" placeholder="Ë´ãËº∏ÂÖ•Á∂≤ÂùÄ...">
    <textarea id="inputHtml" placeholder="Ë´ãË≤º‰∏äÊÇ®ÁöÑHTMLÁ®ãÂºèÁ¢º..."></textarea>
    <div id="conditions-container">
        <div class="condition-group">
            <input type="text" class="tag-a" placeholder="ÈñãÂßãÊ®ôÁ±§ (‰æãÂ¶ÇÔºö<p>)">
            <input type="text" class="tag-b" placeholder="ÁµêÊùüÊ®ôÁ±§ (‰æãÂ¶ÇÔºö</p>)">
            <button onclick="addCondition()">+</button>
            <button onclick="addNotCondition(this)">NOT</button>
            <button class="remove-btn" onclick="removeConditionGroup(this)">X</button>
        </div>
    </div>
    <div class="filter-controls">
        <label for="loadFilter">ËºâÂÖ•ÈÅéÊøæ</label>
        <input type="file" id="loadFilter" accept=".txt" onchange="loadFilter(event)">
        <button onclick="saveFilter()">‰øùÂ≠òÈÅéÊøæ</button>
        <button onclick="extractText()">ËΩâÊèõ</button>
        <input type="text" id="postFilters" placeholder="ÂæåÁΩÆÈÅéÊøæÊ¢ù‰ª∂ (‰ª•ÈÄóËôüÂàÜÈöîÔºå‰æãÂ¶ÇÔºö's,abc)">
    </div>
    
    <!-- ‰øÆÊîπÂæåÁöÑËº∏Âá∫ÂçÄÂüü -->
    <div id="checkboxContainer" class="checkbox-container"></div>
    <div id="outputDiv"></div>
    <button onclick="saveAsTxt()">ÂÑ≤Â≠òÁÇ∫TXT</button>

    <script>
        // Êñ∞Â¢ûÁöÑËÆäÈáè
        let currentParagraphs = [];
        let removedIndices = new Set();
        const colorClasses = ['color-0', 'color-1', 'color-2', 'color-3', 'color-4', 'color-5', 'color-6', 'color-7'];

        function addCondition() {
            const container = document.getElementById('conditions-container');
            const newGroup = document.createElement('div');
            newGroup.className = 'condition-group';
            newGroup.innerHTML = `
                <input type="text" class="tag-a" placeholder="ÈñãÂßãÊ®ôÁ±§ (‰æãÂ¶ÇÔºö<p>)">
                <input type="text" class="tag-b" placeholder="ÁµêÊùüÊ®ôÁ±§ (‰æãÂ¶ÇÔºö</p>)">
                <button onclick="addCondition()">+</button>
                <button onclick="addNotCondition(this)">NOT</button>
                <button class="remove-btn" onclick="removeConditionGroup(this)">X</button>
            `;
            container.appendChild(newGroup);
        }

        function addNotCondition(button) {
            const group = button.parentElement;
            let notInputs = group.querySelector('.not-inputs');
            if (!notInputs) {
                notInputs = document.createElement('div');
                notInputs.className = 'not-inputs';
                group.appendChild(notInputs);
            }
            const newNotPair = document.createElement('div');
            newNotPair.className = 'not-pair';
            newNotPair.innerHTML = `
                <input type="text" class="tag-not-start" placeholder="ÊéíÈô§ÈñãÂßãÊ®ôÁ±§ÊàñÊñáÂ≠ó (‰æãÂ¶ÇÔºö<span> Êàñ 's)">
                <input type="text" class="tag-not-end" placeholder="ÊéíÈô§ÁµêÊùüÊ®ôÁ±§ (‰æãÂ¶ÇÔºö</span>ÔºåÂèØÁïôÁ©∫)">
                <button class="remove-btn" onclick="removeNotPair(this)">X</button>
            `;
            notInputs.appendChild(newNotPair);
        }

        function removeConditionGroup(button) {
            const group = button.parentElement;
            group.remove();
        }

        function removeNotPair(button) {
            const notPair = button.parentElement;
            const notInputs = notPair.parentElement;
            notPair.remove();
            if (notInputs.children.length === 0) {
                notInputs.remove();
            }
        }

        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\']/g, '\\$&');
        }

        function encodeSpecialChars(str) {
            if (typeof str !== 'string') return str;
            return str
                .replace(/"/g, 'üòÑ')
                .replace(/>/g, 'üòÅ')
                .replace(/<\//g, 'üòä');
        }

        function decodeSpecialChars(str) {
            if (typeof str !== 'string') return str;
            return str
                .replace(/üòÑ/g, '"')
                .replace(/üòÅ/g, '>')
                .replace(/üòä/g, '</');
        }

        function extractText() {
            const htmlInput = document.getElementById('inputHtml').value;
            const conditions = document.querySelectorAll('.condition-group');
            const postFiltersInput = document.getElementById('postFilters').value.trim();
            let matches = [];
            let errorMessages = [];

            Array.from(conditions).forEach((group, groupIndex) => {
                const tagA = group.querySelector('.tag-a').value.trim();
                const tagB = group.querySelector('.tag-b').value.trim();
                const notPairs = group.querySelectorAll('.not-pair');

                if (tagA && tagB) {
                    try {
                        const escapedTagA = escapeRegExp(tagA);
                        const escapedTagB = escapeRegExp(tagB);
                        const regexAB = new RegExp(`${escapedTagA}(.*?)${escapedTagB}`, 'gs');

                        let match;
                        while ((match = regexAB.exec(htmlInput)) !== null) {
                            let content = match[1];

                            notPairs.forEach(pair => {
                                const tagNotStart = pair.querySelector('.tag-not-start').value.trim();
                                const tagNotEnd = pair.querySelector('.tag-not-end').value.trim();
                                if (tagNotStart) {
                                    try {
                                        const escapedNotStart = escapeRegExp(tagNotStart);
                                        const escapedNotEnd = tagNotEnd ? escapeRegExp(tagNotEnd) : '';
                                        const regexNot = new RegExp(
                                            escapedNotEnd ? `${escapedNotStart}.*?${escapedNotEnd}` : escapedNotStart,
                                            'gs'
                                        );
                                        content = content.replace(regexNot, '');
                                    } catch (e) {
                                        errorMessages.push(`ÁÑ°ÊïàÁöÑNOTÊ¢ù‰ª∂: ${tagNotStart}-${tagNotEnd}`);
                                    }
                                }
                            });

                            if (content.trim()) {
                                matches.push({ content: content.trim(), groupIndex });
                            }
                        }
                    } catch (e) {
                        errorMessages.push(`ÁÑ°ÊïàÁöÑÊ¢ù‰ª∂ÁµÑ: ${tagA}-${tagB}`);
                    }
                }
            });

            const seen = new Set();
            let extracted = [];
            matches.forEach(match => {
                if (!seen.has(match.content)) {
                    seen.add(match.content);
                    extracted.push(match);
                }
            });

            if (postFiltersInput) {
                const postFilters = postFiltersInput.split(',')
                    .map(f => f.trim())
                    .filter(f => f);
                if (postFilters.length > 0) {
                    extracted = extracted.filter(({ content }) => {
                        return !postFilters.some(filter => {
                            try {
                                const escapedFilter = escapeRegExp(filter);
                                const regexFilter = new RegExp(escapedFilter, 'g');
                                return regexFilter.test(content);
                            } catch (e) {
                                errorMessages.push(`ÁÑ°ÊïàÁöÑÂæåÁΩÆÈÅéÊøæÊ¢ù‰ª∂: ${filter}`);
                                return false;
                            }
                        });
                    });
                }
            }

            extracted.sort((a, b) => a.groupIndex - b.groupIndex);

            currentParagraphs = extracted.map(item => item.content);
            removedIndices = new Set();
            
            updateCheckboxUI();
            updateOutput();

            if (errorMessages.length > 0) {
                alert(`ËôïÁêÜÈÅéÁ®ã‰∏≠ÁôºÁèæ‰ª•‰∏ãÂïèÈ°åÔºö\n${errorMessages.join('\n')}`);
            }
            if (extracted.length === 0 && matches.length > 0) {
                alert('Ë≠¶ÂëäÔºöÊâÄÊúâÊèêÂèñÂÖßÂÆπË¢´ÈÅéÊøæÊ¢ù‰ª∂ÁßªÈô§ÔºåË´ãÊ™¢Êü•Ê¢ù‰ª∂ÁµÑ„ÄÅNOTÊ¢ù‰ª∂ÊàñÂæåÁΩÆÈÅéÊøæË®≠ÁΩÆÔºÅ');
            }
        }

        // Êñ∞Â¢ûÁöÑÂáΩÊï∏
        function updateCheckboxUI() {
            const container = document.getElementById('checkboxContainer');
            container.innerHTML = '';
            
            const rows = [];
            for (let i = 0; i < currentParagraphs.length; i += 5) {
                rows.push(currentParagraphs.slice(i, i + 5));
            }
            
            rows.forEach((row, rowIndex) => {
                const rowContainer = document.createElement('div');
                rowContainer.className = 'checkbox-row';
                
                row.forEach((para, indexInRow) => {
                    const globalIndex = rowIndex * 5 + indexInRow;
                    const colorClass = colorClasses[globalIndex % colorClasses.length];
                    
                    const checkboxItem = document.createElement('div');
                    checkboxItem.className = `checkbox-item ${colorClass}`;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `para-${globalIndex}`;
                    checkbox.checked = !removedIndices.has(globalIndex);
                    checkbox.onchange = function() {
                        if (this.checked) {
                            removedIndices.delete(globalIndex);
                        } else {
                            removedIndices.add(globalIndex);
                        }
                        updateOutput();
                    };
                    
                    const label = document.createElement('label');
                    label.htmlFor = `para-${globalIndex}`;
                    label.textContent = `ÊÆµËêΩ ${globalIndex + 1}`;
                    label.className = colorClass;
                    
                    checkboxItem.appendChild(checkbox);
                    checkboxItem.appendChild(label);
                    rowContainer.appendChild(checkboxItem);
                });
                
                if (row.length > 0) {
                    const rowToggle = document.createElement('div');
                    rowToggle.className = 'row-toggle';
                    
                    const masterCheckbox = document.createElement('input');
                    masterCheckbox.type = 'checkbox';
                    masterCheckbox.checked = row.every((_, indexInRow) => {
                        const globalIndex = rowIndex * 5 + indexInRow;
                        return !removedIndices.has(globalIndex);
                    });
                    masterCheckbox.onchange = function() {
                        row.forEach((_, indexInRow) => {
                            const globalIndex = rowIndex * 5 + indexInRow;
                            if (this.checked) {
                                removedIndices.delete(globalIndex);
                            } else {
                                removedIndices.add(globalIndex);
                            }
                        });
                        updateCheckboxUI();
                        updateOutput();
                    };
                    
                    const label = document.createElement('label');
                    label.textContent = 'ÂÖ®ÈÅ∏';
                    
                    rowToggle.appendChild(masterCheckbox);
                    rowToggle.appendChild(label);
                    rowContainer.appendChild(rowToggle);
                }
                
                container.appendChild(rowContainer);
            });
        }

        function updateOutput() {
            const outputDiv = document.getElementById('outputDiv');
            outputDiv.innerHTML = '';
            
            currentParagraphs.forEach((para, index) => {
                if (!removedIndices.has(index)) {
                    const colorClass = colorClasses[index % colorClasses.length];
                    const paraBlock = document.createElement('div');
                    paraBlock.className = `para-block ${colorClass}`;
                    paraBlock.textContent = para;
                    outputDiv.appendChild(paraBlock);
                }
            });
        }

        function saveFilter() {
            const url = document.getElementById('urlInput').value.trim();
            const postFilters = document.getElementById('postFilters').value.trim();
            const conditions = document.querySelectorAll('.condition-group');
            let filterData = { url: encodeSpecialChars(url), postFilters: encodeSpecialChars(postFilters), conditions: [] };

            conditions.forEach(group => {
                const tagA = group.querySelector('.tag-a').value.trim();
                const tagB = group.querySelector('.tag-b').value.trim();
                let groupData = { tagA: encodeSpecialChars(tagA), tagB: encodeSpecialChars(tagB), notPairs: [] };
                const notPairs = group.querySelectorAll('.not-pair');
                notPairs.forEach(pair => {
                    const tagNotStart = pair.querySelector('.tag-not-start').value.trim();
                    const tagNotEnd = pair.querySelector('.tag-not-end').value.trim();
                    if (tagNotStart || tagNotEnd) {
                        groupData.notPairs.push({
                            tagNotStart: encodeSpecialChars(tagNotStart),
                            tagNotEnd: encodeSpecialChars(tagNotEnd)
                        });
                    }
                });
                if (tagA || tagB || groupData.notPairs.length > 0) {
                    filterData.conditions.push(groupData);
                }
            });

            if (filterData.conditions.length === 0 && !filterData.url && !filterData.postFilters) {
                alert('Ê≤íÊúâÈÅéÊøæÊ¢ù‰ª∂„ÄÅÁ∂≤ÂùÄÊàñÂæåÁΩÆÈÅéÊøæÊ¢ù‰ª∂ÂèØÂÑ≤Â≠òÔºÅ');
                return;
            }

            const blob = new Blob([JSON.stringify(filterData, null, 2)], { type: 'text/plain' });
            const urlBlob = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = urlBlob;
            a.download = 'filter_conditions.txt';
            a.click();
            URL.revokeObjectURL(urlBlob);
        }

        function loadFilter(event) {
            const file = event.target.files[0];
            if (!file) {
                alert('Êú™ÈÅ∏ÊìáÊ™îÊ°àÔºÅ');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const filterData = JSON.parse(e.target.result);
                    if (typeof filterData !== 'object' || filterData === null) {
                        throw new Error('Ê™îÊ°àÊ†ºÂºèÈåØË™§ÔºöÊáâÁÇ∫ÊúâÊïàÁöÑJSONÁâ©‰ª∂');
                    }
                    if (!Array.isArray(filterData.conditions)) {
                        throw new Error('Ê™îÊ°àÊ†ºÂºèÈåØË™§ÔºöÁº∫Â∞ëÊàñÁÑ°ÊïàÁöÑÊ¢ù‰ª∂Èô£ÂàóÔºàconditionsÔºâ');
                    }

                    const container = document.getElementById('conditions-container');
                    const urlInput = document.getElementById('urlInput');
                    const postFiltersInput = document.getElementById('postFilters');
                    container.innerHTML = '';

                    urlInput.value = decodeSpecialChars(typeof filterData.url === 'string' ? filterData.url : '');
                    postFiltersInput.value = decodeSpecialChars(typeof filterData.postFilters === 'string' ? filterData.postFilters : '');

                    filterData.conditions.forEach((groupData, index) => {
                        if (!groupData || typeof groupData !== 'object') {
                            throw new Error(`ÁÑ°ÊïàÁöÑÊ¢ù‰ª∂ÁµÑÊ†ºÂºèÔºàÁ¥¢Âºï ${index}Ôºâ`);
                        }

                        const newGroup = document.createElement('div');
                        newGroup.className = 'condition-group';

                        const inputA = document.createElement('input');
                        inputA.type = 'text';
                        inputA.className = 'tag-a';
                        inputA.placeholder = 'ÈñãÂßãÊ®ôÁ±§ (‰æãÂ¶ÇÔºö<p>)';
                        inputA.value = decodeSpecialChars(groupData.tagA || '');

                        const inputB = document.createElement('input');
                        inputB.type = 'text';
                        inputB.className = 'tag-b';
                        inputB.placeholder = 'ÁµêÊùüÊ®ôÁ±§ (‰æãÂ¶ÇÔºö</p>)';
                        inputB.value = decodeSpecialChars(groupData.tagB || '');

                        const addButton = document.createElement('button');
                        addButton.textContent = '+';
                        addButton.onclick = addCondition;

                        const notButton = document.createElement('button');
                        notButton.textContent = 'NOT';
                        notButton.onclick = function() { addNotCondition(this); };

                        const removeButton = document.createElement('button');
                        removeButton.className = 'remove-btn';
                        removeButton.textContent = 'X';
                        removeButton.onclick = function() { removeConditionGroup(this); };

                        newGroup.appendChild(inputA);
                        newGroup.appendChild(inputB);
                        newGroup.appendChild(addButton);
                        newGroup.appendChild(notButton);
                        newGroup.appendChild(removeButton);

                        if (Array.isArray(groupData.notPairs) && groupData.notPairs.length > 0) {
                            const notInputs = document.createElement('div');
                            notInputs.className = 'not-inputs';
                            groupData.notPairs.forEach((pair, pairIndex) => {
                                if (!pair || typeof pair !== 'object') {
                                    throw new Error(`ÁÑ°ÊïàÁöÑNOTÊ¢ù‰ª∂Ê†ºÂºèÔºàÊ¢ù‰ª∂ÁµÑ ${index}ÔºåNOTÊ¢ù‰ª∂ ${pairIndex}Ôºâ`);
                                }

                                const newNotPair = document.createElement('div');
                                newNotPair.className = 'not-pair';

                                const inputNotStart = document.createElement('input');
                                inputNotStart.type = 'text';
                                inputNotStart.className = 'tag-not-start';
                                inputNotStart.placeholder = 'ÊéíÈô§ÈñãÂßãÊ®ôÁ±§ÊàñÊñáÂ≠ó (‰æãÂ¶ÇÔºö<span> Êàñ \'s)';
                                inputNotStart.value = decodeSpecialChars(pair.tagNotStart || '');

                                const inputNotEnd = document.createElement('input');
                                inputNotEnd.type = 'text';
                                inputNotEnd.className = 'tag-not-end';
                                inputNotEnd.placeholder = 'ÊéíÈô§ÁµêÊùüÊ®ôÁ±§ (‰æãÂ¶ÇÔºö</span>ÔºåÂèØÁïôÁ©∫)';
                                inputNotEnd.value = decodeSpecialChars(pair.tagNotEnd || '');

                                const removeNotButton = document.createElement('button');
                                removeNotButton.className = 'remove-btn';
                                removeNotButton.textContent = 'X';
                                removeNotButton.onclick = function() { removeNotPair(this); };

                                newNotPair.appendChild(inputNotStart);
                                newNotPair.appendChild(inputNotEnd);
                                newNotPair.appendChild(removeNotButton);
                                notInputs.appendChild(newNotPair);
                            });
                            if (notInputs.children.length > 0) {
                                newGroup.appendChild(notInputs);
                            }
                        }

                        container.appendChild(newGroup);
                    });

                    if (container.children.length === 0) {
                        addCondition();
                    }
                } catch (err) {
                    alert('ËºâÂÖ•ÈÅéÊøæÊ¢ù‰ª∂Â§±ÊïóÔºö' + err.message);
                }
            };
            reader.onerror = function() {
                alert('ËÆÄÂèñÊ™îÊ°àÂ§±ÊïóÔºåË´ãÊ™¢Êü•Ê™îÊ°àÊòØÂê¶ÊúâÊïàÔºÅ');
            };
            reader.readAsText(file);
        }

        function saveAsTxt() {
            let outputText = '';
            
            currentParagraphs.forEach((para, index) => {
                if (!removedIndices.has(index)) {
                    outputText += para + '\n\n';
                }
            });

            if (!outputText.trim()) {
                alert('Ê≤íÊúâÊñáÂ≠óÂèØÂÑ≤Â≠òÔºÅ');
                return;
            }

            const blob = new Blob([outputText.trim()], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ÊèêÂèñÊñáÂ≠ó.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>